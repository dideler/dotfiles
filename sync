#!/usr/bin/env bash

# Enable error checking.
set -e

if [[ "$1" == "-h" || "$1" == "--help" ]]; then cat <<HELP
Usage: $(basename "$0") [-h --help] [-f --force]

Symbolically links files in your dotfiles repository with your HOME directory.
The actual dotfiles should be in this directory, links/pointers to your dotfiles
will be created in $HOME. Directories are not symlinked, but the files within
them are. If a directory in the dotfiles repository doesn't exist in your home
directory, it will be created there.

Steps:
1. Move any dotfiles in HOME that you want symlinked, to your dotfiles
   repository (this directory). If some of your dotfiles are in a directory,
   that directory's structure has to be imitated in your dotfiles repository.
2. Run the sync script to create the symlinks.

It's recommended you host your dotfiles repository on a remote code hosting
service (e.g. GitHub, GitLab, BitBucket, private server). This will make it easy
for you to use your dotfiles on a new machine. Simply clone the repository then
run the sync script.

Use the -f or --force flag to remove existing files with the same link name.

See the README for more info:  https://github.com/dideler/dotfiles#readme

Copyright (c) 2014 Dennis Ideler
Licensed under the MIT license.
HELP
exit; fi

# Globals.
force_flag=""
overwrite_all=false
backup_all=false
skip_all=false

# Fancy logging.
BOLD=$(tput bold)
UNDERLINE=$(tput smul)
REVERSE=$(tput rev)
NORMAL=$(tput sgr0)
BLACK=0 RED=1 GREEN=2 YELLOW=3 BLUE=4 MAGENTA=5 CYAN=6 WHITE=7 # For light colours, use with bold.
background_colour() { tput setab $1; }
font_colour() { tput setaf $1; }

print_bright() { echo -e "${BOLD}$(font_colour $1)${@:2}${NORMAL}"; }
print_dim()    { echo -e "$(font_colour $1)${@:2}${NORMAL}"; }
print_path()   { echo "$(font_colour $WHITE)$(pretty_path $1)${NORMAL}"; }
print_info()   { echo -e "\n $(print_bright $YELLOW $@)"; }
print_prompt() { echo -e "\n $(print_bright $BLUE ?)  $@"; }
print_pass()   { echo -e " $(print_bright $GREEN ✔)  $@"; }
print_fail()   { echo -e " $(print_bright $RED ✗)  $@"; }
print_link()   { echo -e "Linked $(print_path $1) $(print_bright $YELLOW ➜)  $(print_path $2)"; }
print_move()   { echo -e "Moved $(print_path $1) $(print_bright $YELLOW ➜)  $(print_path $2)"; }

# Returns a pretty pathname.
# Replaces the first part of the pathname with '~' if it is the same as $HOME.
pretty_path() {
  local pathname="$1"
  [[ "$pathname" =~ ^"$HOME"(/|$) ]] && pathname="~${pathname#$HOME}"
  echo "$pathname"
}

# Remove the leading dot from all hidden files and dirs, except '.git' and '.gitignore'.
unhide() {
  find . \( -iname ".*" ! -iname ".git" ! -iname ".gitignore" \) -print0 | xargs -r0 rename -v 's|/\.+([^/]+)$|/$1|'
}

# Removes all the (visible) contents of your dotfiles repository except the files specified.
clean_repo() {
  find . -not -name 'README.md' -not -name 'LICENSE' -not -name 'sync' -delete
  print_success "Repository cleaned"
}

# TODO: copy files manually (since different for every user) and remove this function
copy_dotfiles() {
  print_info "Copying dotfiles"
  #clean_repo
  # Copy the desired dot files to this directory.
  #rsync --relative --archive --verbose --update --no-perms \
  #      ~/.{bash_aliases,vimrc,gitconfig,config/fish/config.fish,config/fish/functions/} \
  #      ~/.{vim/plugin/,vim/syntax/,ssh/config*,weechat/*.conf,config/redshift.conf} .
  # Get rid of the /home/user/ path by moving all files out of there and deleting the directory.
  #rsync --archive --remove-source-files ./home/$(whoami)/ .
  #rm -rf ./home
}

# Creates a symbolic link to a file.
link() {
  # All variables declared inside a function will be shared with the calling
  # environment, unless declared local (though they are still shared with called
  # environments). Don't pollute global namespace!
  local relative_filepath="${1:2}"  # Remove leading "./" by extracting substring.
  local homedir="$2"
  local target="$(pwd)/$relative_filepath"  # Original file (absolute filepath).
  local link_name="$homedir/$relative_filepath"  # Pointer file.

  # Linking directories doesn't end well, so we avoid them and only link files.
  # But we create directories in our home directory if they do not exist yet.
  if [[ -d $target ]]; then
    # A directory and file cannot exist at the same level with the same name.
    # Proceeds if any file with that name doesn't exist, instead of a directory.
    if [[ ! -e $link_name ]]; then
      mkdir --parents $link_name
      print_pass "Created directory $(print_path $link_name)"
    fi
    # Directory (or file) now exists in $HOME, move along to the next file.
    return
  fi

  # Enters conflict resolution if force flag not set and link already exists.
  if [ -z $force_flag ] && [ -f $link_name -o -d $link_name ]; then
    local overwrite=false
    local backup=false
    local skip=false

    # Prompts for current action if no global action is set.
    if [ "$overwrite_all" == "false" -a "$backup_all" == "false" -a "$skip_all" == "false" ]; then
      print_prompt "Destination file already exists for $(print_path $(basename $target))
      Do you want to [${BOLD}${UNDERLINE}s${NORMAL}]kip, [${BOLD}S${NORMAL}]kip all, [${BOLD}o${NORMAL}]verwrite, [${BOLD}O${NORMAL}]verwrite all, [${BOLD}b${NORMAL}]ackup, [${BOLD}B${NORMAL}]ackup all?"
      read -n 1 action && echo
      case "$action" in
        o )
          overwrite=true ;;
        O )
          overwrite_all=true ;;
        b )
          backup=true ;;
        B )
          backup_all=true ;;
        s )
          skip=true ;;
        S )
          skip_all=true ;;
        * )
          print_fail "Unrecognized option, skipping $target"
          skip=true ;;
      esac
    fi

    if [ "$overwrite" == "true" -o "$overwrite_all" == "true" ]; then
      ln --symbolic --force $target $link_name
      print_pass "Removed existing destination file $link_name"
    fi

    if [ "$backup" == "true" -o "$backup_all" == "true" ]; then
      mv $link_name $link_name\.backup
      print_pass $(print_move $link_name $link_name.backup)
      ln --symbolic $target $link_name
    fi

    if [ "$skip" == "true" -o "$skip_all" == "true" ]; then
      print_pass "Skipped $(print_path $target)"
      continue  # A return should be here, but continue strangely works!
    fi

  else # Don't worry about conflicts, link away!
    ln --symbolic $force_flag $target $link_name
  fi

  print_pass $(print_link $link_name $target)
}

# Symbolically links files in your dotfiles repo to your $HOME.
# For example, if your dotfiles repo has a file named `.foo`,
# this will create a pointer: $HOME/.foo ➜  ~/path/to/dotfiles/.foo
link_dotfiles() {
  print_info "Creating links in $HOME to your dotfiles..."
  # TODO: check ignored files before publishing
  local dotfiles=$(find -not -iwholename '*.git*' -not -name 'LICENSE' -not -name 'README.md' -not -name 'sync*' -not -name '.')
  # An alternative way to find the dotfiles:
  # find -type d -name .git -prune -o -not -name 'LICENSE' -not -name 'README.md' -not -name 'sync*' -not -name '.' -print
  for file in $dotfiles; do  # Known issue: does not work with filenames w/ spaces.
    link $file $HOME
    #echo "$file"
    #if [[ -d $file ]]; then  # IF file exists and is directory...
    #  echo "is directory"
    #else
    #  echo "is file"
    #fi
  done
}

run_tests() {
  print_info foo bar
  print_prompt foo bar
  print_pass foo bar
  print_fail foo bar
  print_link foo bar
  print_move foo bar
  echo "flag has value $force_flag"
  echo "this is ${BOLD}bold${NORMAL} but this isn't"
  font_colour $RED
  echo "red text"
  font_colour $GREEN
  echo "green text"
  font_colour $WHITE
  echo "grey text"
  echo "${NORMAL}white text"
  pretty_path "$HOME/foo"
}

main() {
  if [[ "$1" == "-f" || "$1" == "--force" ]]; then
    force_flag="--force"
  fi

  run_tests
  link_dotfiles
  print_info "Done!"
}


main "$@"  # Call main and pass args.
